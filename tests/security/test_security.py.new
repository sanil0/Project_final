"""Security test suite for DDoS protection system."""

import os
import time
import logging
from typing import Dict, Set
import pytest
from fastapi import FastAPI, Request, Response
from fastapi.testclient import TestClient
from fastapi.middleware.cors import CORSMiddleware
from starlette.middleware.base import BaseHTTPMiddleware
from app.middleware.ddos_protection import DDoSProtectionMiddleware
from app.utils.ip import extract_client_ip

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Constants and configuration
ALLOWED_ORIGINS = ["http://localhost:3000", "http://127.0.0.1:3000"]
ALLOWED_HOSTS = ["localhost", "localhost:3000", "127.0.0.1", "127.0.0.1:3000"]
SECURITY_HEADERS = {
    'X-Content-Type-Options': 'nosniff',
    'X-Frame-Options': 'DENY',
    'X-XSS-Protection': '1; mode=block',
    'Strict-Transport-Security': 'max-age=31536000; includeSubDomains',
    'Content-Security-Policy': "default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval'; style-src 'self' 'unsafe-inline';",
    'Referrer-Policy': 'strict-origin-when-cross-origin',
    'Cache-Control': 'no-store, max-age=0',
    'Feature-Policy': "accelerometer 'none'; camera 'none'; geolocation 'none'; gyroscope 'none'; magnetometer 'none'; microphone 'none'; payment 'none'; usb 'none'"
}

# Global state for rate limiting and IP blacklist
rate_limit_store: Dict[str, Dict[str, any]] = {}
blacklist_store: Set[str] = set()

class SecurityMiddleware(BaseHTTPMiddleware):
    """Security middleware for request filtering and protection."""
    
    def __init__(self, app, allowed_hosts=None, rate_limit=30, window_size=60, csrf_enabled=True, allowed_origins=None):
        """Initialize the security middleware."""
        super().__init__(app)
        self.allowed_hosts = [h.lower() for h in (allowed_hosts or ALLOWED_HOSTS)]
        self.rate_limit = rate_limit
        self.window_size = window_size
        self.csrf_enabled = csrf_enabled
        self.allowed_origins = [o.lower() for o in (allowed_origins or ALLOWED_ORIGINS)]
    
    async def __call__(self, request: Request, call_next) -> Response:
        """Process the request with security measures."""
        try:
            client_ip = extract_client_ip(request, [], True)  # Use default settings for tests
            
            # Host header validation (normalized comparison)
            host = request.headers.get("Host", "").lower().strip()
            if not any(host == allowed for allowed in self.allowed_hosts):
                return Response(
                    status_code=400,
                    content='{"error": "Invalid host header"}',
                    media_type="application/json",
                    headers=SECURITY_HEADERS
                )

            # IP blacklist check
            if client_ip in blacklist_store:
                return Response(
                    status_code=403,
                    content='{"error": "IP address blocked"}',
                    media_type="application/json",
                    headers=SECURITY_HEADERS
                )

            # Rate limiting
            current_time = time.time()
            if client_ip not in rate_limit_store:
                rate_limit_store[client_ip] = {"count": 0, "timestamp": current_time}
            
            window_start = rate_limit_store[client_ip]["timestamp"]
            
            # Reset counter if window has passed
            if current_time - window_start >= self.window_size:
                rate_limit_store[client_ip] = {"count": 0, "timestamp": current_time}
                window_start = current_time
            
            # Increment counter first
            rate_limit_store[client_ip]["count"] += 1
            current_count = rate_limit_store[client_ip]["count"]
            remaining = max(0, self.rate_limit - current_count)

            # Check rate limit after increment
            if current_count > self.rate_limit:
                reset_time = int(window_start + self.window_size)
                return Response(
                    status_code=429,
                    content='{"error": "Rate limit exceeded"}',
                    media_type="application/json",
                    headers=dict(SECURITY_HEADERS, **{
                        "X-RateLimit-Limit": str(self.rate_limit),
                        "X-RateLimit-Remaining": "0",
                        "X-RateLimit-Reset": str(reset_time)
                    })
                )

            # CORS and CSRF protection
            origin = request.headers.get("Origin", "").lower().strip()
            method = request.method

            if method == "OPTIONS":
                # Handle CORS preflight
                response = Response(
                    status_code=200,
                    content="",
                    headers=dict(SECURITY_HEADERS)  # Make sure we include security headers in OPTIONS
                )
                if origin and origin in self.allowed_origins:
                    response.headers.update({
                        "Access-Control-Allow-Origin": origin,
                        "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS",
                        "Access-Control-Allow-Headers": "Content-Type, X-CSRF-Token",
                        "Access-Control-Max-Age": "600",
                        "Vary": "Origin"
                    })
                return response

            # CSRF protection for non-GET requests
            if method != "GET" and self.csrf_enabled:
                if not origin or origin not in self.allowed_origins:
                    return Response(
                        status_code=403,
                        content='{"error": "CSRF validation failed"}',
                        media_type="application/json",
                        headers=SECURITY_HEADERS
                    )

            # Process the request
            response = await call_next(request)
            
            # Add security headers to all responses
            response.headers.update(SECURITY_HEADERS)
            
            # Add rate limit headers
            reset_time = int(window_start + self.window_size)
            response.headers.update({
                "X-RateLimit-Limit": str(self.rate_limit),
                "X-RateLimit-Remaining": str(remaining),
                "X-RateLimit-Reset": str(reset_time)
            })

            # Add CORS headers if needed
            if origin and origin in self.allowed_origins:
                response.headers.update({
                    "Access-Control-Allow-Origin": origin,
                    "Vary": "Origin"
                })
            
            return response

        except Exception as e:
            logger.error(f"Security middleware error: {str(e)}")
            return Response(
                status_code=500,
                content='{"error": "Internal server error"}',
                media_type="application/json",
                headers=SECURITY_HEADERS
            )

# Test fixtures
@pytest.fixture
def app():
    """Create a FastAPI test app with security middleware."""
    app = FastAPI()
    
    # Add security middleware
    app.add_middleware(
        SecurityMiddleware,
        allowed_hosts=ALLOWED_HOSTS,
        rate_limit=30,
        window_size=60,
        csrf_enabled=True,
        allowed_origins=ALLOWED_ORIGINS
    )
    
    # Test routes - only what's needed for tests
    @app.get("/")
    async def root():
        """Root endpoint for testing."""
        return {"status": "ok"}
        
    @app.get("/api/test")
    async def test_endpoint():
        """Test endpoint."""
        return {"status": "ok"}
        
    return app

@pytest.fixture
def client(app):
    """Create a test client."""
    return TestClient(app)

@pytest.fixture(autouse=True)
def setup():
    """Reset state before each test."""
    rate_limit_store.clear()
    blacklist_store.clear()
    yield  # This allows cleanup after each test

class TestSecurity:
    """Test suite for security middleware."""

    def test_security_headers(self, client):
        """Test that security headers are correctly set."""
        response = client.get("/")
        assert response.status_code == 200
        
        # Check security headers
        headers = response.headers
        assert headers["X-Content-Type-Options"] == "nosniff"
        assert headers["X-Frame-Options"] == "DENY"
        assert headers["X-XSS-Protection"] == "1; mode=block"
        assert "max-age=31536000" in headers["Strict-Transport-Security"]
        assert "default-src 'self'" in headers["Content-Security-Policy"]
        assert headers["Referrer-Policy"] == "strict-origin-when-cross-origin"
        assert headers["Cache-Control"] == "no-store, max-age=0"

    def test_rate_limiting(self, client):
        """Test rate limiting functionality."""
        # Make requests up to the limit
        for i in range(30):
            response = client.get("/")
            assert response.status_code == 200
            assert response.headers["X-RateLimit-Remaining"] == str(29 - i)

        # This request should be rate limited
        response = client.get("/")
        assert response.status_code == 429
        assert response.json()["error"] == "Rate limit exceeded"
        assert response.headers["X-RateLimit-Remaining"] == "0"

    def test_host_header_validation(self, client):
        """Test host header validation."""
        valid_hosts = ["localhost", "localhost:3000", "127.0.0.1", "127.0.0.1:3000"]
        invalid_hosts = ["evil.com", "attacker.net", "malicious.org"]

        # Test valid hosts
        for host in valid_hosts:
            response = client.get("/", headers={"Host": host})
            assert response.status_code == 200

        # Test invalid hosts
        for host in invalid_hosts:
            response = client.get("/", headers={"Host": host})
            assert response.status_code == 400
            assert response.json()["error"] == "Invalid host header"

    def test_cors_configuration(self, client):
        """Test CORS configuration."""
        # Test preflight request
        headers = {
            "Origin": "http://localhost:3000",
            "Access-Control-Request-Method": "POST",
            "Access-Control-Request-Headers": "Content-Type"
        }
        response = client.options("/", headers=headers)
        assert response.status_code == 200
        assert response.headers["Access-Control-Allow-Origin"] == "http://localhost:3000"
        assert "POST" in response.headers["Access-Control-Allow-Methods"]
        # Verify security headers are present in OPTIONS response
        assert "X-Content-Type-Options" in response.headers

        # Test actual request
        headers = {"Origin": "http://localhost:3000"}
        response = client.get("/", headers=headers)
        assert response.status_code == 200
        assert response.headers["Access-Control-Allow-Origin"] == "http://localhost:3000"

    def test_csrf_protection(self, client):
        """Test CSRF protection."""
        # Test POST without Origin header (should fail)
        response = client.post("/api/test")
        assert response.status_code == 403
        assert response.json()["error"] == "CSRF validation failed"

        # Test POST with valid Origin header
        headers = {"Origin": "http://localhost:3000"}
        response = client.post("/api/test", headers=headers)
        assert response.status_code == 200

        # Test POST with invalid Origin header
        headers = {"Origin": "http://evil.com"}
        response = client.post("/api/test", headers=headers)
        assert response.status_code == 403
        assert response.json()["error"] == "CSRF validation failed"

    def test_ip_blacklisting(self, client):
        """Test IP blacklisting functionality."""
        # Test normal request
        response = client.get("/")
        assert response.status_code == 200

        # Add IP to blacklist
        blacklist_store.add("127.0.0.1")

        # Test request from blacklisted IP
        response = client.get("/")
        assert response.status_code == 403
        assert response.json()["error"] == "IP address blocked"